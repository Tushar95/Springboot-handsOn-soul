package com.handson.soul.controller;import com.handson.soul.service.RateLimitingDemoService;import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;import io.github.resilience4j.ratelimiter.annotation.RateLimiter;import io.github.resilience4j.retry.annotation.Retry;import io.github.resilience4j.timelimiter.annotation.TimeLimiter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.concurrent.CompletableFuture;@RestControllerpublic class DemoController {    private final RestTemplate restTemplate = new RestTemplate();//    @Autowired    private final RateLimitingDemoService rateLimitingDemo;    public DemoController(RateLimitingDemoService rateLimitingDemo) {        this.rateLimitingDemo = rateLimitingDemo;    }    //    @CircuitBreaker(name="myService", fallbackMethod = "fallbackResponse")    @Retry(name="myService", fallbackMethod = "fallbackResponse")    @GetMapping("/call-external")    public String callExternalService() throws InterruptedException {        return restTemplate.getForObject("http://localhost:8081/fail", String.class);    }    //    @GetMapping("/limited")    public String limitedEndpoint() {//        return rateLimitingDemo.simulateRateLimit();        return rateLimitingDemo.processRequest();    }    //    @TimeLimiter(name="timeoutService")    @CircuitBreaker(name="timeoutService", fallbackMethod = "timeoutFallback")    @GetMapping("/delayed")    public CompletableFuture<String> delayedService() {        return CompletableFuture.supplyAsync(() -> {            try {                Thread.sleep(5000); // simulate delay            } catch (InterruptedException e) {            }            return "Delayed Response";        });    }    private String fallbackResponse(Exception ex) {        return "âš¡ Service is down. Returning fallback response.";    }    private CompletableFuture<String> timeoutFallback(Exception ex) {        return CompletableFuture.completedFuture("Request Timeout");    }}